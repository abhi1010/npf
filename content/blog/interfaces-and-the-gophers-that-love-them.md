+++
title = "Interfaces and the Gophers That Love Them"
date = 2014-04-18T13:58:00Z
updated = 2014-04-18T13:58:55Z
draft = true
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

Interfaces are one of the best features of Go, and the one most confusing to people who have used interfaces in other languages.  This is not an introduction to interfaces, I'm going to assume you know how they work, more or less. This is more of a post about how to effectively use interfaces and avoid the mistake of assuming they should be used like they are in other languages.<br /><br />Interfaces in Go are different than those in most other statically typed languages like C++, Java, or C# - Go's interfaces are <i>implicitly</i> fulfilled, rather than explicitly. What this means is that the type that satisfies the interface doesn't even have to know the interface exists. All that is required is that the type have the correct methods.  This has some far reaching ramifications that are not always immediately obvious.<br /><br />In other languages, you write an interface for a type. For example, you might have an interface to abstract away document storage in your system, so that you can use a database, filesystem, network, or in-memory storage.  Since these languages require interfaces to be explicitly implemented by types, you end up making the interface very wide (having lots of methods).  If you miss exposing a method in the interface, you can't access that method unless you go back and add it to the interface, and then add the implementation of the method to each of the implementations of the concrete types.  Generally you have one factory method to get whatever implementation you want, returning it as an interface, which then the rest of your system uses.  Often times, a lot of the implementation details are shared across the different types, so they may share a base class that implements some of the more basic functionality which is then added on to by the derived types.<br /><br />While you can do similar things in Go, this is often not the best way to leverage Go's interfaces.  In fact, using Go's interfaces in the most efficient way possible often involves turning your code inside out.<br /><br />There are two rules to keep in mind when using Go with interfaces:<br /><br /><b>1.) Go's interfaces work best when they are very small.</b><br /><br /><b>2.) Design interfaces for functions, not for types.</b><br /><br />These two rules go hand in hand, and are a direct result of Go's implicit satisfaction of interfaces.  Let's look at one of the canonical Go interfaces, io.Writer.  It has only a single method: Write(p []byte) (n int, err error).  All it does is write some bytes from the given slice.  So, why is it so awesome?  It is a very narrowly focused interface, so almost anything can implement it without much difficulty - network connections, files, in-memory byte buffers, or even things like Stdout and Stderr.  The focus is narrow, but the signature is very basic.  Take some data to write, return the number of bytes that were written, plus an error in case something goes wrong.  That's about as basic as you can get.  What this means is that it's easy to write functions that use this interface in different ways.  Any function that needs to write out data to a value can do so by taking an io.Writer.  <br /><br />It also means it's very easy to transform the data being written, just write a wrapper that wraps another io.Writer, and you now have a writer that can, for example, gzip the data before it gets written, or strip out newlines, or do base64 encoding, or anything else you can imagine.  And this kind of transformation can be easily inserted into a pipeline of data without any of the rest of the parts of the system even being aware of it.<br /><br />And it's all possible because io.Writer is a tiny little interface written in a very basic way, so a whole bunch of functions and types can implement it and use it in their own way.<br /><br /><br /><br />
