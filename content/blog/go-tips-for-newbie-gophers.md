+++
title = "Go Tips for Newbie Gophers"
date = 2014-03-15T09:00:00Z
updated = 2014-03-21T11:02:33Z
tags = ["Go", "programming", "golang"]
blogimport = true 
type = "post"
[author]
	name = "Nate Finch"
	uri = "https://plus.google.com/115818189328363361527"
+++

This is just a collection of tips that would have saved me a lot of time if I had known about them when I was a newbie:<br /><br /><b>Build or test everything under the current directory and subdirectories:</b><br /><b><br /></b><span style="font-family: Courier New, Courier, monospace;">go build ./...</span><br /><span style="font-family: Courier New, Courier, monospace;">go test ./...</span><br /><span style="font-family: Courier New, Courier, monospace;"><br /></span><span style="font-family: inherit;">Technically, both commands take a pattern to match the name of one or more packages, and the ... specifier is a wildcard, so you could do .../foo/... to match all packages under GOPATH with foo in their path.&nbsp;</span><br /><br /><b>Have an io.Writer that writes to an in-memory data structure:</b><br /><br /><div><span style="font-family: Courier New, Courier, monospace;">b := &amp;bytes.Buffer{}</span><br /><span style="font-family: Courier New, Courier, monospace;">thing.WriteTo(b)</span><br /><br /><b>Have an io.Reader read from a string (useful when you want to use a string as the input data for something):</b><br /><span style="font-family: Courier New, Courier, monospace;"><br /></span><span style="font-family: Courier New, Courier, monospace;">r := strings.NewReader(myString)</span><br /><span style="font-family: Courier New, Courier, monospace;">thing.ReadFrom(r)</span><br /><br /><b>Copy data from a reader to a writer:</b><br /><br /><span style="font-family: Courier New, Courier, monospace;">io.Copy(toWriter, fromReader)</span><br /><br /><b>Timeout waiting on a channel:</b><br /><br /><span style="font-family: Courier New, Courier, monospace;">select {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp;case val := &lt;- ch</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp;// use val</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp;case &lt;-time.After(time.Second*5)</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><br /><b>Convert a slice of bytes to a string:</b><br /><br /><span style="font-family: Courier New, Courier, monospace;">var b []byte = getData()</span><br /><span style="font-family: Courier New, Courier, monospace;">s := string(b)</span><br /><br /><b>Passing a nil pointer into an interface does not result in a nil interface:</b><br /><br /><span style="font-family: Courier New, Courier, monospace;">func isNil(i interface{}) bool {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; return i == nil</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><span style="font-family: Courier New, Courier, monospace;"><br /></span><span style="font-family: Courier New, Courier, monospace;">var f *foo = nil</span><br /><div><span style="font-family: Courier New, Courier, monospace;">fmt.Println(isNil(f)) &nbsp;// prints false</span></div><div><br /></div><div><b>The only way to get a nil interface is to pass the keyword nil:</b></div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace;">var f *foo = nil</span><br /><span style="font-family: Courier New, Courier, monospace;">if f == nil {</span><br /><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; fmt.Println(isNil(nil)) &nbsp;// prints true</span></div></div><div><span style="font-family: Courier New, Courier, monospace;">}</span></div><div><br /></div><div><b>How to remember where the arrow goes for channels:</b></div><div><br /></div><div>The arrow points in the direction of data flow, either into or out of the channel, and always points left.</div><div><br /></div><div><b>The above is generalizable to anything where you have a source and destination, or reading and writing, or assigning.</b></div><div><b><br /></b></div><div>Data is taken from the right and assigned to the left, just as it is with a := b. &nbsp;So, like io.Copy, you know that the reader (source) is on the right, the writer (destination) is on the left: &nbsp;io.Copy(dest, src).</div><div><br /></div><div><b>If you ever think "man, someone should have made a helper function to do this!", chances are they have, and it's in the std lib somewhere.</b></div></div>
